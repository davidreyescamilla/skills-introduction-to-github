# -*- coding: utf-8 -*-
"""Rey Escamilla, David-E-FEM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LefQmBh9Jzgwd5aww43Hr4Lj2_aGgW87
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.tri as tri
from scipy.sparse.linalg import spsolve
from scipy.special import lambertw
import matplotlib.animation as animation

# Model:

# The model's geometry is expressed in a list containing its nodes. The nodes are described by their coordinates, so we will identify the nodes by its index in this array, and we will bw able to access its coordinates with that index:
nodes = np.array([[0,0],
                  [1,0],
                  [1,1],
                  [0,1]])

# The elements are conformed as per the node's connectivity. We will fins the elements listed in an array, and we will be able to access them by their index. Every item in tis array will contain the nodes in every element:
elements = np.array([[1, 2, 3],
                     [3, 4, 1]])

for i, element in enumerate(elements):
    # Correct indexing for Python (0-based)
    element = element - 1
    elements[i] = element

# Boundary conditions:

# Let's create variables for the traction to easily modify them:
surface_traction = 1e6  # Presure in N/m^2

# Now, we establish the boundary conditions: [segment coordinates [init, end], type, value (scalar (value) or vector (x,y))]
# BC type legend:
#   U = displacements (m)
#   f = distributed force (Pa)

boundary_conditions = [[[[0,0],[0,1]],'U',0,"free"], [[[0,0],[1,0]],'U',"free",0], [[[0,1],[1,1]],'U',"free",0], [[[1,0],[1,1]],'f',surface_traction,0]]
    # Note: for displacements we can use "free"

# Material properties

E = 26e9        # Young's modulus (Pa)
nu = 0.2        # Poisson's ratio
sigma_y = 2e6   # Tensile strenght (Pa)
G_f = 74        # Fracture energy (N/m)

# Plot the mesh

def plot_mesh(nodes, elements, boundary_conditions):
    for element in elements:
        polygon = [nodes[node - 1] for node in element]
        polygon.append(polygon[0])  # Close the loop
        plt.plot(*zip(*polygon), marker='o', color='blue')

    for segment, bc_type, _, _ in boundary_conditions:
        plt.plot(*zip(*segment), color='red' if bc_type == 'U' else 'green')

    plt.gca().set_aspect('equal', adjustable='box')
    plt.show()

plot_mesh(nodes, elements, boundary_conditions)

# FEM:

# Then, we will create a function to compute the area (to know the area of the element, det(J) = 2A). For a given "element" (listed in the array "elements") we will compute their area by accessing to their nodal coordinates, listed in the array "nodes":
def area(element):
    """Compute the area of an element"""
    x1, y1 = nodes[element[0]]
    x2, y2 = nodes[element[1]]
    x3, y3 = nodes[element[2]]
    return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)

# The following function will help with automatizing the computation of the shape functions. This simply changes the position of the "nodes" in an "element":
def cyclic_permutation(element):
    """Perform cyclic permutation of an element's nodes"""
    return np.array([element[1], element[2], element[0]])


def N(element, x, y):
    """Compute the [N] matrix"""
    N = np.zeros([2, 2*len(element)])

    for permutation in range(len(element)): # For every permutation we compute the shape functions corresponding to one node (indices [0, 1, 2] become [1, 2, 0] in the permuted "element" array):
        x1, y1 = nodes[element[0]]
        x2, y2 = nodes[element[1]]
        x3, y3 = nodes[element[2]]
        ai = x2 * y3 - x3 * y2
        bi = y2 - y3
        ci = x3 - x2
        shape_function = (ai + bi * x + ci * y)
        N[0][2*permutation] = shape_function
        N[1][2*permutation+1] = shape_function

        element = cyclic_permutation(element)

    return N / 2 * area(element)


def B(element): # The [B] matrix for a CST element is constant, therefore it is independent from x or y.
    """Compute the [B] matrix of an element"""
    B = np.zeros([3, 2 * len(element)])

    for permutation in range(len(element)):
        x1, y1 = nodes[element[0]]
        x2, y2 = nodes[element[1]]
        x3, y3 = nodes[element[2]]

        B[0, 2*permutation] = y2 - y3
        B[1, 2*permutation+1] = x3 - x2
        B[2, 2*permutation] = x3 - x2
        B[2, 2*permutation+1] = y2 - y3

        element = cyclic_permutation(element)

    return B / 2 * area(element)


# Define a function to compute the material constitutive matrix. This will deppend on the type of problem treated; in this case, plane strain for an isotropic material is assumed:
def C(E, nu):
    """Compute the material constitutive law matrix"""
    C = np.array([[1-nu, nu,   0         ],
                  [nu,   1-nu, 0         ],
                  [0,    0,    (1-2*nu)/2]]) # CHECK: / 2 correction for Voight notation strain tensor.

    return C * E/((1+nu)*(1-2*nu))


# Functions to check boundary conditions and applied surface tractions:
# We define a function that checks if a given node is in a certain segment:
def node_in_segment(node, segment):
    """Check if a node is in a segment"""
    v1 = nodes[int(node)] - np.array(segment[1])
    v2 = np.array(segment[0]) - np.array(segment[1])

    if np.cross(v1,v2) == 0 and \
       (min(segment[0][0],segment[1][0]) <= nodes[node][0] <= max(segment[0][0],segment[1][0])) and \
       (min(segment[0][1],segment[1][1]) <= nodes[node][1] <= max(segment[0][1],segment[1][1])):
        return True
    else:
        return False


# Assembly of the global stiffness matrix and force vector:
def assembly(elements):
    """Assemble the global stiffness matrix and force vector"""
    # Global stiffness matrix initialization
    n_dofs = 2 * len(nodes)
    K = np.zeros([n_dofs, n_dofs])

    # Global force vector initialization:
    F = np.zeros(n_dofs)

    # Vectorized assembly
    element_dofs = []
    values = []

    C_mat = C(E, nu)

    for element in elements:
        # Compute local stiffness matrix. This is int_{\Omega} [B]^T [C] [B] d\Omega.
        B_mat = B(element)
        K_e = area(element) * (B_mat.T @ C_mat @ B_mat) # Numerical integration is performed by multiplying bt the area, as both [B] and [C] are independent from x and y

        # Get global DOF indices for the current element
        global_dofs = np.array([2 * node + i for node in element for i in range(2)]) # For every element, this creates a list of the position in the global stiffness matrix of the dofs "i" of every "node"

        # Record contributions to the global matrix
        for i in range(2 * len(element)):
            for j in range(2 * len(element)):
                element_dofs.append((global_dofs[i], global_dofs[j])) # Record the global DOFs in a specific "element"
                values.append(K_e[i, j]) # Record the "K_e" value to add in the global "K" matrix

        # Global force vector assembly:
        # Loop over edges of the element
        for i in range(len(element)):
            # Current edge nodes
            n1, n2 = element[i], element[(i + 1) % len(element)]

            # Check if edge matches a boundary condition
            for condition in boundary_conditions:
                segment, bc_type, tx, ty = condition

                if bc_type == 'f' and node_in_segment(n1, segment) and node_in_segment(n2, segment):
                    # Compute edge length
                    edge_length = np.linalg.norm(nodes[n2] - nodes[n1])

                    # Traction vector
                    traction = np.array([tx, ty])

                    # Local force contributions (constant distribution)
                    f_local = (edge_length / 2) * np.array([*traction, *traction])

                    # Add contributions to the global force vector
                    global_dofs = [2 * n1, 2 * n1 + 1, 2 * n2, 2 * n2 + 1]
                    for dof, f in zip(global_dofs, f_local):
                        F[dof] += f

    # Convert to sparse matrix format
    from scipy.sparse import coo_matrix

    row_indices, col_indices = zip(*element_dofs)
    K_sparse = coo_matrix((values, (row_indices, col_indices)), shape=(n_dofs, n_dofs))
    K = K_sparse.toarray()  # Convert back to dense if needed

    # Impose boundary conditions on displacement:
    for condition in boundary_conditions:
        segment, bc_type, ux, uy = condition
        if bc_type == 'U':
            for i, node in enumerate(nodes):
                if node_in_segment(i, segment):
                    if ux != "free":
                        F[2 * i] = ux
                        K[:, 2 * i] = 0
                        K[2 * i, :] = 0
                        K[2 * i, 2 * i] = 1
                    if uy != "free":
                        F[2 * i + 1] = uy
                        K[:, 2 * i + 1] = 0
                        K[2 * i + 1, :] = 0
                        K[2 * i + 1, 2 * i + 1] = 1
    return K, F

# Solve for displacements
K, F = assembly(elements)
u = spsolve(K, F)
print(u.reshape(-1, 2))

# Plot the displacements

# Create the triangulation object
triangulation = tri.Triangulation(nodes[:, 0], nodes[:, 1], elements)

# Compute magnitude of displacements for visualization
u_x = u[0::2]  # x-displacement (even indices)
u_y = u[1::2]  # y-displacement (odd indices)
u_magnitude = np.sqrt(u_x**2 + u_y**2)

# Plot the displacement magnitude
plt.figure(figsize=(8, 6))
plt.tricontourf(triangulation, u_magnitude, levels=20, cmap='viridis')
plt.colorbar(label='Displacement Magnitude (m)')
plt.title('Displacement Magnitude')
plt.xlabel('x (m)')
plt.ylabel('y (m)')
plt.gca().set_aspect('equal', adjustable='box')
plt.show()

# Compute strains and stress fields

def compute_strains(elements, u):
    epsilon = np.zeros([len(elements), 3])
    for i, element in enumerate(elements):
        u_e = np.array([u[2 * node + j] for node in element for j in range(2)])
        epsilon[i] = B(element) @ u_e
    return epsilon

def compute_stress(elements, u):
    epsilon = compute_strains(elements, u)
    sigma = np.zeros([len(elements), 3])
    for i in range(len(epsilon)):
        sigma[i] = C(E, nu) @ epsilon[i]
    return sigma

# E-FEM considering strong discontinuities

"""
Linear system of equations:
[K_bb  K_bw  K_bs       ]   {\delta d              }   {- A{f_int^e - f_ext^e}}
[K_wb  K_ww  K_ws       ] · {\delta [|\varepsilon|]} = {- h_[|\varepsilon|]   }
[K_s*b K_s*w K_s*s + K_q]   {\delta [u]            }   {- \Phi_0              }

Simplification to account only for strong discontinuities:
[K_bb  K_bs       ]   {\delta d              }   {- A{f_int^e - f_ext^e}}
[K_s*b K_s*s + K_q]   {\delta [u]            } = {- \Phi_0              }

-\Phi_0 = 0 => K_s*b · \delta d + (K_s*s + K_q) · \delta [u] = 0 => \delta [u] = (K_s*s + K_q)^(-1) · K_s*b · \delta d

So the entire system can be reduced to:
K_sc · \delta d = - A{f_int^e - f_ext^e}
Where:
K_sc = (K_bb - K_bs · (K_s*s + K_q)^(-1) · K_s*b)

Localization criteria: In this first iteration, the crack is predefined, so we know beforehand its location and normal vector
"""

crack_opening = 0.5 # x coordinate of the crack opening
n = np.array([1, 0]) # Normal vector of the crack opening

def heaviside(x):
    """Compute the heaviside function"""
    if x < crack_opening: return 0
    # elif node == crack_opening: return 0.5 # This line can be problematic if a node of an element is in the crack opening
    else: return 1

def G_s(element, n):
    """Compute the G_s matrix"""
    x1, y1 = nodes[element[0]]
    x2, y2 = nodes[element[1]]
    x3, y3 = nodes[element[2]]
    b1, b2, b3 = (y2 - y3) * heaviside(x1), (y3 - y1) * heaviside(x2), (y1 - y2) * heaviside(x3)
    c1, c2, c3 = (x3 - x2) * heaviside(x1), (x1 - x3) * heaviside(x2), (x2 - x1) * heaviside(x3)
    # In the E-FEM formulation, we find a sum for all elements in \Omega^+, however for the SKON formulation G = dH, so by the moment G will be defined at an elementary level and then assembled in a global matrix
    dphi_dx = (b1 + b2 + b3) / (2 * area(element))
    dphi_dy = (c1 + c2 + c3) / (2 * area(element))
    # Compute \nabla \phi:
    G_s = np.zeros((3, 2 * len(element)))
    G_s[0, 0::2] = dphi_dx
    G_s[1, 1::2] = dphi_dy
    G_s[2, 0::2] = dphi_dy
    G_s[2, 1::2] = dphi_dx
    return G_s

def H_s(n):
    """Compute the H_s matrix"""
    nx, ny = n
    H_s = np.zeros((3, 2 * len(element)))
    H_s[0, 0::2] = nx
    H_s[1, 1::2] = ny
    H_s[2, 0::2] = ny
    H_s[2, 1::2] = nx
    return H_s

def K_bb(element):
    """Compute the stiffness matrix K_bb"""
    B_mat = B(element)
    C_mat = C(E, nu)
    return area(element) * (B_mat.T @ C_mat @ B_mat)

def K_bs(element, n):
    """Compute the stiffness matrix K_bs"""
    n_e = np.tile(n, len(element)) # Replicate the normal vector for the expanded matrices
    B_mat = B(element)
    C_mat = C(E, nu)
    G_s_mat = G_s(element, n)
    return area(element) * B_mat.T @ C_mat @ G_s_mat @ n_e.reshape(-1, 1)

def K_sb(element, n):
    """Compute the stiffness matrix K_sb"""
    n_e = np.tile(n, len(element)) # Replicate the normal vector for the expanded matrices
    H_s_mat = H_s(n)
    C_mat = C(E, nu)
    B_mat = B(element)
    return n_e.reshape(1, -1) @ H_s_mat.T @ C_mat @ B_mat

def K_ss(element, n):
    """Compute the stiffness matrix K_ss"""
    n_e = np.tile(n, len(element)) # Replicate the normal vector for the expanded matrices
    H_s_mat = H_s(n)
    C_mat = C(E, nu)
    G_s_mat = G_s(element, n)
    return n_e.reshape(1, -1) @ H_s_mat.T @ C_mat @ G_s_mat @ n_e.reshape(-1, 1)

def K_q(sigma_y, G_f, u_modulus):
    """Compute the stiffness matrix K_q"""
    return (sigma_y**2 / G_f) * np.exp(- (sigma_y / G_f) * u_modulus)

def u_discontinuity(sigma_y, G_f, element, n, d):
    """Compute the magnitude of the crack displacement"""
    T_e = K_sb(element, n) @ d
    M = K_ss(element, n)
    u_disc = (G_f / sigma_y) * (lambertw(sigma_y**2 * np.exp(sigma_y * T_e / (G_f * M)) / (G_f * M)) - sigma_y * T_e / (G_f * M))
    return u_disc.real

def K_sc(sigma_y, G_f, element, n, d):
    """Compute the stiffness matrix K_sc"""
    K_bb_mat = K_bb(element)
    K_bs_mat = K_bs(element, n)
    K_sb_mat = K_sb(element, n)
    K_ss_mat = K_ss(element, n)
    K_q_mat = K_q(sigma_y, G_f, u_discontinuity(sigma_y, G_f, element, n, d))
    return K_bb_mat - (K_bs_mat @ K_sb_mat) / (K_ss_mat + K_q_mat)

# Localization and opening criteria:
"""
With this first (purely geometric) approach, we will project the traction vector in the normal direction to the crack opening (predefined).
Localization will take place when this component of the traction vector reaches a treshold (sigma_y)
"""
def sigma_projection(sigma, n):
    """Project the sigma vector in the normal direction"""
    nx, ny = n
    sigma_xx, sigma_yy, sigma_xy = sigma
    return sigma_xx * nx**2 + sigma_yy * ny**2 + 2 * sigma_xy * nx * ny

def T(element, n, sigma_e):
    """Compute the traction vector for a give element"""
    nx, ny = n
    H_s_mat = np.zeros((len(element), 2)) # Notice it is more convinient to redefine H_s for this specific case
    H_s_mat[0, 0] = nx
    H_s_mat[1, 1] = ny
    H_s_mat[2, 0] = ny
    H_s_mat[2, 1] = nx
    return H_s_mat.T @ sigma_e

def potential(sigma_y, G_f, element, n, d):
    """Compute the potential function"""
    T_e = K_sb(element, n) @ d
    M = K_ss(element, n)
    u_disc = u_discontinuity(sigma_y, G_f, element, n, d)
    return T_e + M * u_disc - sigma_y * np.exp(- (sigma_y / G_f) * u_disc)

# Check that all extra matrices dimensions are correct

print(K_bb(elements[0]))
print('')
print(K_bs(elements[0], n))
print('')
print(K_sb(elements[0], n))
print('')
print(K_ss(elements[0], n))
print('')
print(K_bs(elements[0], n) @ K_sb(elements[0], n))

# IMPL-EX iterative solver

def iterative_solver(E, nu, sigma_y, G_f, elements, nodes):
    """
    Perform the non-linear analysis using the IMPL-EX iterative solver.

    Parameters:
        E: Elastic modulus.
        nu: Poisson's ratio.
        sigma_y: Yield stress.
        G_f: Fracture energy.
        elements: Element connectivity.
        nodes: Node coordinates.

    Returns:
        tuple: Displacement states at each step.
    """
    # Initialize variables
    K, F = assembly(elements)
    F_incremental = np.zeros(len(F))
    displacement_states = [np.zeros(2 * len(nodes))]
    stiffness_states = [K.copy()]
    n_vectors = {}
    iteration = 0

    # Constants
    TOLERANCE = 1e-4
    MAX_ITER = 100
    a_ref = sigma_y / E
    max_damage = 0

    while np.linalg.norm(F_incremental) < np.linalg.norm(F):
        if iteration == 0:
            d, delta_f, F_incremental, R = initial_iteration(K, F, sigma_y, elements, nodes)
            if delta_f is None:  # No cracking detected
                displacement_states.append(d)
                return displacement_states
            else:
                displacement_states.append(d)
                iteration += 1
                print(f'Iteration {iteration}: Load factor {np.linalg.norm(F_incremental) / np.linalg.norm(F)}')
        else:
            delta_f_next = compute_delta_f(iteration, delta_f, R, max_damage, TOLERANCE, a_ref, displacement_states)
            F_incremental += delta_f_next * F
            d, K, delta_f, F_incremental, R, n_vectors = IMPL_EX_solver(displacement_states, stiffness_states, n_vectors, delta_f_next, delta_f, F_incremental, TOLERANCE, MAX_ITER)
            displacement_states.append(d) # d will be added to d_states after the local loop has concluded
            stiffness_states.append(K) # K will be added to K_states, to monitor the evolution of the stiffness matrix
            delta_f = delta_f_next
            if np.linalg.norm(displacement_states[-1] - displacement_states[-2]) == 0:
                print(f"Failure occurred at load factor {np.linalg.norm(F_incremental) / np.linalg.norm(F)}")
                break
            iteration += 1
            print(f'Iteration {iteration}: Load factor {np.linalg.norm(F_incremental) / np.linalg.norm(F)}')
    return displacement_states


def initial_iteration(K, F, sigma_y, elements, nodes):
    """Handle the initial iteration with simplified logic"""
    # Solve initial system
    d = spsolve(K, F)
    sigma = compute_stress(elements, d)
    sigma_projected = np.array([sigma_projection(s, n) for s in sigma])

    # Check if cracking occurs
    cracks = sigma_projected >= sigma_y
    if cracks.any():
        delta_f = 0.1 * (sigma_y / max(sigma_projected))
        f_incremental = F * delta_f
        d = spsolve(K, f_incremental)
        R = f_incremental - K @ d
        return d, delta_f, f_incremental, R
    else:
        return d, None, None, None

def compute_delta_f(iteration, delta_f, R, max_damage, tolerance, a_ref, displacement_states):
    """Compute the next load increment"""
    if iteration <= 2:
        return delta_f * np.sqrt((tolerance * a_ref) / max(np.linalg.norm(R), tolerance * a_ref))
    else:
        delta_displacements = displacement_states[-1] - displacement_states[-2]
        delta_displacements_prev = displacement_states[-2] - displacement_states[-3]
        return delta_f * np.sqrt(tolerance * a_ref / max(max(abs(delta_displacements - delta_displacements_prev)), tolerance * a_ref))

def IMPL_EX_solver(displacement_states, stiffness_states, n_vectors, delta_f_next_init, delta_f_init, F_incremental, tolerance, max_iter):
    """Perform the non-linear analysis using the IMPL-EX solver"""
    local_iter = 0
    d, delta_d, K, delta_f_next, delta_f = displacement_states[-1], displacement_states[-1] - displacement_states[-2], stiffness_states[-1], delta_f_next_init, delta_f_init

    R = F_incremental - K @ d

    while np.linalg.norm(R) > tolerance:
        tilde_d = d + (delta_f_next / delta_f) * delta_d
        sigma = compute_stress(elements, tilde_d)
        for e, element in enumerate(elements):
            # Check if a crack will appear or propagate
            if sigma_projection(sigma[e], n) >= sigma_y:
                global_dofs = np.array([2 * node + i for node in element for i in range(2)])
                K, K_sc_mat = modify_K(K, sigma_y, G_f, element, n, tilde_d[global_dofs], global_dofs)
                """
                Test
                local_damage = update_damage(K_states, K_sc_mat, element, global_dofs)
                """
        # Recalculate the residual vector after modifying K(global)
        R = F_incremental - K @ tilde_d # Now, because K is more compliant, we can expect tilde_d to have underestimated the real displacement
        delta_d, d = tilde_d - d, tilde_d # Update the variables to compute the next tilde_d
        local_iter += 1

        if local_iter == max_iter:
            # Make the step half the size of the previous one
            delta_f_next *= 0.5
            F_incremental -= delta_f_next * F
            # Restore the last stiffness and displacement saved in K_states and d_states
            K, d = stiffness_states[-1], displacement_states[-1]
            delta_d = displacement_states[-1] - displacement_states[-2]
            R = F_incremental - K @ d
            local_iter = 0

        elif np.linalg.norm(delta_d) == 0:
            return d, K, delta_f_next, F_incremental, R, n_vectors
    return d, K, delta_f_next, F_incremental, R, n_vectors

def modify_K(K, sigma_y, G_f, element, n, d, global_dofs):
    """Modify the global stiffness matrix"""
    K_global = K
     # Capture the global dofs to be modified in global K
    # Compute the elementary degradated stiffness matrix ([u] = f(tilde_d), K_sc = f([u])):
    K_sc_mat = K_sc(sigma_y, G_f, element, n, d)
    # Modify the global stiffness matrix with the newely computed local K_sc:
    K[np.ix_(global_dofs, global_dofs)] = K_sc_mat
    return K_global, K_sc_mat

"""Test"""
# Damage factor driven increment:
def update_damage(K_states, K_sc_mat, element, global_dofs):
    """Compute the pseudo-damage factor"""
    """
    Now, because we do not have a scalar damage factor, we will be using the norm of the degraded stiffness matrix to compute the following time step increments
    First, we "normalize" the K_sc matrix wrt the initial K_bb matrix of the element:
        K_sc = K_bb - (K_bs @ K_sb) / (K_ss_mat + K_q_mat) = K_bb·(I - K_bb⁽⁻¹⁾ @ K_bs @ K_sb / (K_ss_mat + K_q_mat))
    Therefore:
        K_bb⁽⁻¹⁾ @ K_sc = I - K_bb⁽⁻¹⁾ @ K_bs @ K_sb / (K_ss_mat + K_q_mat)
    Which kind of looks like a damage factor, but in matricial form
    """
    I_norm = np.linalg.norm(np.identity(6), ord='fro')
    K_bb_mat = K_bb(element)
    K_bb_mat_inv = np.linalg.pinv(K_bb_mat)
    damage = np.linalg.norm(K_bb_mat_inv @ (K_bb_mat - K_sc_mat), ord='fro') / I_norm
    damage_prev = np.linalg.norm(K_bb_mat_inv @ (K_bb_mat - K_states[-1][global_dofs, :][:, global_dofs]), ord='fro') / I_norm
    damage_prev_prev = np.linalg.norm(K_bb_mat_inv @ (K_bb_mat - K_states[-2][global_dofs, :][:, global_dofs]), ord='fro') / I_norm
    damage = abs(damage - damage_prev - (damage_prev - damage_prev_prev))
    return damage

iterative_solver(E, nu, sigma_y, G_f, elements, nodes)

# E-FEM principal stress lead cracking
"""
Because we have an isotropic material, we don't really know where the crack will initiate. Therefore we will implement the stress-driven crack nucleation and propagation criterion.
In this case, the stress treshold is not compared to the projection of the stress tensor, but to the maximum eigenvalue; then, the normal vector representing the orientation of the crack in a given element is its respective eigenvector.

We need a new way to define \Omega⁺ and \Omega⁻. We do not have much information about the exact point where the crack is originated, so we will project the crack from the barycenter of the triancle.
It is fair to say this is not such a great approach regarding crack continuity, but if the mesh is fine enought it should be an "okish" method to discriminate between those nodes in \Omega⁻ and those in \Omega⁺.
This is also coherent with the construction of the sigular part of the displacement field (heaviside function).

An interesting remark is because we will be taking the highest of the eigenvalues, as it is given the crack will not propagate under compression, the eigenvector orientation will discriminate itself the two regions of \Omega.
"""
# We have to redefine the function to compute
def heaviside(x, y, x0, y0, n):
    """Compute the heaviside function"""
    nx, ny = n
    f = nx * (x - x0) + ny * (y - y0)
    if f < 0: return 0
    # elif node == crack_opening: return 0.5 # This line can be problematic if a node of an element is in the crack opening
    else: return 1

def G_s(element, n):
    """Compute the G_s matrix"""
    x1, y1 = nodes[element[0]]
    x2, y2 = nodes[element[1]]
    x3, y3 = nodes[element[2]]
    x0 = (x1 + x2 + x3) / 3
    y0 = (y1 + y2 + y3) / 3

    b1, b2, b3 = (y2 - y3) * heaviside(x1, y1, x0, y0, n), (y3 - y1) * heaviside(x2, y2, x0, y0, n), (y1 - y2) * heaviside(x3, y3, x0, y0, n)
    c1, c2, c3 = (x3 - x2) * heaviside(x1, y1, x0, y0, n), (x1 - x3) * heaviside(x2, y2, x0, y0, n), (x2 - x1) * heaviside(x3, y3, x0, y0, n)
    # In the E-FEM formulation, we find a sum for all elements in \Omega^+, however for the SKON formulation G = dH, so by the moment G will be defined at an elementary level and then assembled in a global matrix
    dphi_dx = (b1 + b2 + b3) / (2 * area(element))
    dphi_dy = (c1 + c2 + c3) / (2 * area(element))
    # Compute \nabla \phi:
    G_s = np.zeros((3, 2 * len(element)))
    G_s[0, 0::2] = dphi_dx
    G_s[1, 1::2] = dphi_dy
    G_s[2, 0::2] = dphi_dy
    G_s[2, 1::2] = dphi_dx
    return G_s

# We need an easy way to reshape the stress tensor, in Voigt notation, to its matricial form
def eigen_sigma(E, nu, epsilon):
    """Reshape the stress tensor"""
    sigma = np.zeros((3, 3))
    sigma[0, 0] = (1 - nu) * epsilon[0] + nu * epsilon[2]
    sigma[1, 1] = (1 - nu) * epsilon[1] + nu * epsilon[0]
    sigma[2, 2] = nu * (epsilon[0] + epsilon[1])
    sigma[0, 1] = sigma[1, 0] = (1 - 2 * nu) / 2 * epsilon[2]
    sigma *= E / ((1 + nu) * (1 - 2 * nu))

    # Compute eigenvalues and eigenvectors
    eigenvalues, eigenvectors = np.linalg.eig(sigma)
    # Find the index of the maximum eigenvalue
    max_index = np.argmax(eigenvalues)
    # Return the maximum eigenvalue and its corresponding eigenvector
    """Note: we will be taking the first two coordinates of the eigenvector. As we are dealing with a plane problem we will assume the eigenvalues found for the max stress will be in-plane."""
    return eigenvalues[max_index], eigenvectors[:2, max_index]

def compute_epsilon_e(element, d):
    """Compute the strain tensor"""
    B_mat = B(element)
    return B_mat @ d

# And modify some of the functions accordingly:
def initial_iteration(K, F, sigma_y, elements, nodes):
    """Handle the initial iteration with simplified logic"""
    # Solve initial system
    d = spsolve(K, F)
    epsilon = compute_strains(elements, d)
    eigenvalues_sigma = np.array([eigen_sigma(E, nu, e)[0] for e in epsilon])

    # Check if cracking occurs
    cracks = eigenvalues_sigma >= sigma_y
    if cracks.any():
        delta_f = 0.1 * (sigma_y / max(eigenvalues_sigma))
        f_incremental = F * delta_f
        d = spsolve(K, f_incremental)
        R = f_incremental - K @ d
        return d, delta_f, f_incremental, R
    else:
        return d, None, None, None

# Now, the IMPL-EX solver will also use and update the crack orientation for the different elements
def IMPL_EX_solver(displacement_states, stiffness_states, n_vectors_init, delta_f_next_init, delta_f_init, F_incremental, tolerance, max_iter):
    """Perform the non-linear analysis using the IMPL-EX solver"""
    local_iter = 0
    d, delta_d, K, delta_f_next, delta_f, n_vectors = displacement_states[-1], displacement_states[-1] - displacement_states[-2], stiffness_states[-1], delta_f_next_init, delta_f_init, n_vectors_init

    R = F_incremental - K @ d

    while np.linalg.norm(R) > tolerance:
        tilde_d = d + (delta_f_next / delta_f) * delta_d
        sigma = compute_stress(elements, tilde_d)
        for e, element in enumerate(elements):
            global_dofs = np.array([2 * node + i for node in element for i in range(2)])
            eigenvalue, eigenvector = eigen_sigma(E, nu, compute_epsilon_e(element, tilde_d[global_dofs]))
            if eigenvalue >= sigma_y:
                n_vectors.setdefault(e, eigenvector)  # Add eigenvector if not already present
            if e in n_vectors:  # Perform stiffness modification only if a crack is present
                K, K_sc_mat = modify_K(K, sigma_y, G_f, element, n_vectors[e], tilde_d[global_dofs], global_dofs)
        # Recalculate the residual vector after modifying K(global)
        R = F_incremental - K @ tilde_d # Now, because K is more compliant, we can expect tilde_d to have underestimated the real displacement
        delta_d, d = tilde_d - d, tilde_d # Update the variables to compute the next tilde_d
        local_iter += 1

        if local_iter == max_iter:
            # Make the step half the size of the previous one
            delta_f_next *= 0.5
            F_incremental -= delta_f_next * F
            # Restore the last stiffness and displacement saved in K_states and d_states
            K, d = stiffness_states[-1], displacement_states[-1]
            delta_d = displacement_states[-1] - displacement_states[-2]
            # Restore also the crack orientation state
            n_vetors = n_vectors_init
            R = F_incremental - K @ d
            local_iter = 0

        elif np.linalg.norm(delta_d) == 0:
            return d, K, delta_f_next, F_incremental, R, n_vectors
    return d, K, delta_f_next, F_incremental, R, n_vectors

displacement_states = iterative_solver(E, nu, sigma_y, G_f, elements, nodes)

# Plot the displacements

"""
IGNORE: This is to run the animation in Google Colab
from IPython.display import HTML
"""

factor_of_deformation = 100

# Function to modify node positions
def modify_nodes(nodes_coordinates, displacement):
    x_coordinates = nodes_coordinates[:, 0] + factor_of_deformation * displacement[0::2]
    y_coordinates = nodes_coordinates[:, 1] + factor_of_deformation * displacement[1::2]
    nodes_modified = np.column_stack((x_coordinates, y_coordinates))
    return nodes_modified

# Create the figure and axis
fig, ax = plt.subplots()
ax.set_aspect('equal', adjustable='box')
ax.set_xlim(-1, 2)  # Adjust limits as per your mesh
ax.set_ylim(-1, 2)

# List to store all frames
images = []

# Build frames for the animation
for displacement in displacement_states:
    nodes_modified = modify_nodes(nodes, displacement)
    frame_artists = []
    for element in elements:
        polygon = [nodes_modified[node - 1] for node in element]
        polygon.append(polygon[0])  # Close the loop
        line, = ax.plot(*zip(*polygon), marker='o', color='black')  # Get a single Line2D object
        frame_artists.append(line)
    images.append(frame_artists)

# Create the animation
anim = animation.ArtistAnimation(fig, images, interval=100, blit=True, repeat_delay=1000)

plt.show()

"""
# Show the animation in Jupyter Notebook
plt.close(fig)  # Prevent a static plot from being displayed
HTML(anim.to_jshtml())
"""
